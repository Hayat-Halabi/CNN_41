# CNN_41
# Wildlife Photo Augmentation with Multiple Images
# Problem Statement:
You are tasked with building a Convolutional Neural Network (CNN) to classify images of animals into four categories: Squirrel, Elephant, Kangaroo, and Lion. You need to create a model that can accurately classify these animals based on the input images.

# Overview:
You have a set of images for each of the four animal categories. The images have varying dimensions, so you need to preprocess and standardize them. To improve the model's performance, you'll apply data augmentation techniques to increase the diversity of your training dataset.

After building and training the CNN model, you'll visualize its training history to evaluate its performance. Finally, you'll demonstrate how to use the trained model to make predictions on new images.

# Directions:
### Load and Display Images:

Load the provided animal images, including a Squirrel, Elephant, Kangaroo, and Lion.
Display these images in a single plot.
### Data Augmentation:

Define a function augment_data that performs data augmentation on the input data (X and y).
Apply the following augmentation techniques:
Rotation by 20 degrees.
Horizontal shift of 20% of the image width.
Vertical shift of 20% of the image height.
Horizontal flip.
Use ImageDataGenerator from TensorFlow.
### Label Assignment:

Create a dictionary that maps animal names (Squirrel, Elephant, Kangaroo, Lion) to numerical labels (0, 1, 2, 3).
### Data Preprocessing:

Convert the loaded images to numpy arrays and normalize them by dividing by 255.0.
Ensure that all images have the same dimensions by resizing them to the dimensions of the smallest image.
### Model Architecture:

Build a CNN model using the following layers:
Convolutional layer with 32 filters, a 3x3 kernel, and ReLU activation.
MaxPooling layer with a 2x2 pool size.
Convolutional layer with 64 filters, a 3x3 kernel, and ReLU activation.
MaxPooling layer with a 2x2 pool size.
Convolutional layer with 128 filters, a 3x3 kernel, and ReLU activation.
MaxPooling layer with a 2x2 pool size.
Flatten layer.
Dropout layer with a 50% dropout rate.
Fully connected layer with 512 units and ReLU activation.
Output layer with the number of units equal to the number of labels (4) and softmax activation.
### Model Compilation:

Compile the model using the Adam optimizer and categorical cross-entropy as the loss function.
Monitor accuracy as a metric.
### Model Training:

Train the model using the data generated by the augment_data function.
Train for 50 epochs and set verbose to 1 to display training progress.
### Training Visualization:

Plot two subplots:
Subplot 1: Loss evolution (plot the training loss).
Subplot 2: Accuracy evolution (plot the training accuracy).
### Example Prediction:

Select one of the preprocessed images.
Use the trained model to make a prediction on this image.
Print the predicted class (animal name) based on the model's output.

By following these directions, you'll create a CNN model for animal classification and verify its performance using data augmentation and visualization techniques.
``` python
import numpy as np
from skimage import io
import matplotlib.pyplot as plt
import tensorflow as tf
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import Conv2D, MaxPooling2D, Flatten, Dense, Dropout
from tensorflow.keras.preprocessing.image import ImageDataGenerator
from tensorflow.keras.utils import to_categorical

# Image file paths
image_files = {
    "Squirrel": "Squirrel-header.jpg",
    "Elephant": "elephant.jpg",
    "Kangaroo": "Kangaroo.jpg",
    "Lion": "Lion.jpg"
}
images = {name: io.imread(file_path) for name, file_path in image_files.items()}
print(images)
fig, axes = plt.subplots(1, len(images), figsize=(20, 5))
for ax, (name, img) in zip(axes, images.items()):
    ax.imshow(img)
    ax.axis('off')
    ax.set_title(name)

plt.tight_layout()
plt.show()
```
Define a function augment_data that performs data augmentation on the input data (X and y).
Apply the following augmentation techniques:
Rotation by 20 degrees.
Horizontal shift of 20% of the image width.
Vertical shift of 20% of the image height.
Horizontal flip.
Use ImageDataGenerator from TensorFlow.
NOTE: The code below manually augments data. You were to do this using the ImageDataGenerator class from TensorFlow.
```python
import matplotlib.pyplot as plt
import numpy as np

def manual_augment_and_display(images):
    def horizontal_shift(image, shift): # Shift images
        if shift > 0:
            return np.pad(image, ((0, 0), (shift, 0), (0, 0)), mode='constant')[:, :-shift]
        elif shift < 0:
            return np.pad(image, ((0, 0), (0, -shift), (0, 0)), mode='constant')[:, -shift:]
        else:
            return image

    num_images = len(images)
    num_columns = 4  # Display original, horizontal flip, vertical flip, and shifted images
    fig, axes = plt.subplots(num_images, num_columns, figsize=(20, 5 * num_images))

    for idx, (name, img) in enumerate(images.items()):
        ax_row = axes[idx]

        # Display original image
        ax_row[0].imshow(img)
        ax_row[0].set_title(f"Original {name}")
        ax_row[0].axis('off')

        # Display horizontally flipped image
        h_flipped_img = np.fliplr(img) # flip image horizontally
        ax_row[1].imshow(h_flipped_img)
        ax_row[1].set_title(f"Horizontally Flipped {name}")
        ax_row[1].axis('off')

        # Display vertically flipped image
        v_flipped_img = np.flipud(img) # flip image vertically
        ax_row[2].imshow(v_flipped_img)
        ax_row[2].set_title(f"Vertically Flipped {name}")
        ax_row[2].axis('off')

        # Display horizontally shifted image
        h_shifted_img = horizontal_shift(img, 50)  # Shift by 50 pixels
        ax_row[3].imshow(h_shifted_img)
        ax_row[3].set_title(f"Shifted {name}")
        ax_row[3].axis('off')

    plt.tight_layout()
    plt.show()

# Example usage with your 'images' dictionary
manual_augment_and_display(images)
# Data augmentation using ImageDataGenerator class.

def augment_data(X, y, batch_size=32): # Function that will augment data.
    # Create ImageDataGenerator object.
    train_datagen = ImageDataGenerator(
        rotation_range=20, # Rotate
        width_shift_range=0.2, # Vertical shift
        height_shift_range=0.2, # Horizontal shift
        horizontal_flip=True, # Horizontal flip
        vertical_flip=True,  # Add vertical flip
        fill_mode='nearest'
    )

    train_datagen.fit(X) # Fit ImageDataGenerator to data

    # flow() method takes input images and corresponding labels and returns augmented images
    return train_datagen.flow(X, y, batch_size=batch_size)

#Assign labels to the images.
labels = {
    "Squirrel": 0,
    "Elephant": 1,
    "Kangaroo": 2,
    "Lion": 3
}
#Convert the images and labels into lists for easier processing.
X = list(images.values())
y = [labels[name] for name in images.keys()]
#Convert the images into NumPy arrays and normalize them.
X = [img.astype('float32') / 255.0 for img in X] # normalize pixels
#Convert the data into NumPy arrays.
X_train = [np.array(X[0]), np.array(X[1]), np.array(X[2]), np.array(X[3])]
# X_train = np.array(X)
y_train = to_categorical(np.array(y))
#Ensure all images have the same dimensions (resizing to the smallest image dimensions).
min_shape = min([(img.shape[0], img.shape[1]) for img in X_train]) # Find dimensions of smallest image
print(f'Smallest image dimensions: {min_shape}')

X_train_resized = np.array([tf.image.resize(img, min_shape).numpy() for img in X_train]) # resize all images to size of smallest image

#Augment the data, Call function to augment data
train_datagen = augment_data(X_train_resized, y_train)
```
Build the CNN model, compile it, and create a summary.
Build a CNN model using the following layers:

Convolutional layer with 32 filters, a 3x3 kernel, and ReLU activation.
MaxPooling layer with a 2x2 pool size.
Convolutional layer with 64 filters, a 3x3 kernel, and ReLU activation.
MaxPooling layer with a 2x2 pool size.
Convolutional layer with 128 filters, a 3x3 kernel, and ReLU activation.
MaxPooling layer with a 2x2 pool size.
Flatten layer.
Dropout layer with a 50% dropout rate.
Fully connected layer with 512 units and ReLU activation.
Output layer with the number of units equal to the number of labels (4) and softmax activation.
Model Compilation:

Compile the model using the Adam optimizer and categorical cross-entropy as the loss function.
Monitor accuracy as a metric.
```python
# CNN Model
model = Sequential([
    Conv2D(32, (3, 3), activation='relu', input_shape=(min_shape[0], min_shape[1], 3)),
    MaxPooling2D(2, 2),
    Conv2D(64, (3, 3), activation='relu'),
    MaxPooling2D(2, 2),
    Conv2D(128, (3, 3), activation='relu'),
    MaxPooling2D(2, 2),
    Flatten(),
    Dropout(0.5),
    Dense(512, activation='relu'),
    Dense(len(labels), activation='softmax')
])

# Compile the model
model.compile(optimizer='adam', loss='categorical_crossentropy', metrics=['accuracy'])

# Model summary
model.summary()
#Train the model and plot two subplots
# Training
history = model.fit(
    train_datagen,
    epochs=50,
    verbose=1
)

# Visualize the training results
plt.figure(figsize=(12, 4))

plt.subplot(1, 2, 1)
plt.plot(history.history['loss'], label='Loss')
plt.legend()
plt.title('Loss evolution')

plt.subplot(1, 2, 2)
plt.plot(history.history['accuracy'], label='Accuracy')
plt.legend()
plt.title('Accuracy evolution')

plt.tight_layout()
plt.show()
#Make a prediction using an image of your choice.
# Example prediction
# Follow the labeling guide here
# 0 = Squirrel
# 1 = Elephant
# 2 = Kangaroo
# 3 = Lion
sample_image = X_train_resized[3]


predictions = model.predict(np.array([sample_image]))
print(f'Predictions: {predictions}')

predicted_class = np.argmax(predictions) # get index/position of max value
print(f'Predicted class index: {predicted_class}')

print(f"Predicted class: {list(labels.keys())[predicted_class]}") # Use index to retrieve predicted class from labels dictionary
